PROTOCOLO BINARIO PARA SINCRONIZACIÓN DE JUGADORES Y VOXELS SOBRE WEBSOCKETS

══════════════════════════════════════════════════════════════════════════════

PRINCIPIOS DE DISEÑO

• Batching por frame: un frame WS puede contener varios submensajes. Menos syscalls y overhead.
• Servidor autoritativo + tick: el servidor procesa a tick_rate fijo (ej., 30 Hz) y empaqueta los cambios de ese tick.
• Interés espacial: el cliente publica su centro de interés y el servidor solo envía entidades/voxels cercanos.
• Máscaras de componentes: cada actualización declara qué campos cambiaron; no se repiten datos iguales.
• Cuantización: usa enteros compactos en vez de f32 donde sea razonable (ahorro de ancho de banda y cache).
• Clases de fiabilidad (lógico):
  ▸ Crítico (join/leave, cambios de chunk/voxel, snapshots): siempre se envían (TCP ya garantiza).
  ▸ Ephemeral (posición/orientación alta frecuencia): se colapsan; si una cola al cliente se llena, se descarta lo viejo.
• LE (little-endian) en todas partes.
• Sin compresión WS al inicio; si algún payload crece (ej., snapshots de chunk), añade RLE simple casero.

══════════════════════════════════════════════════════════════════════════════

ENCAPSULADO GENERAL

Cada frame WS del servidor al cliente es:

┌─ FrameHeader ─────────────────────────┐
│ u8  type = 0x10 (ServerFrame)         │
│ u32 tick        (monotónico, wrap ok) │
│ u8  submsg_count                      │
└───────────────────────────────────────┘
[SubMsg]*        (submsg_count entradas)

Cliente → Servidor:

┌─ ClientFrame ─────────────────────────┐
│ u8  type = 0x11                       │
│ u32 client_tick_or_seq                │
│ u8  submsg_count                      │
└───────────────────────────────────────┘
[SubMsg]*

Nota: Puedes enviar múltiples SubMsg en un único frame WS. Si prefieres ultra-simple,
también puedes mandar submensajes como frames WS independientes: el contenido no cambia.

══════════════════════════════════════════════════════════════════════════════

IDENTIFICADORES Y RANGOS

• EntityId: u32 (jugadores/NPC/objetos).
• Chunk coord: mundo voxel particionado en chunks 16×16×16:
  ▸ i32 cx, cy, cz para chunk absolutos.
  ▸ Índice local del voxel: u16 v = vx | (vy<<4) | (vz<<8) con vx,vy,vz ∈ [0,15].
• TextureId/PaletteId: u16 (si te quedas corto, pasa a u24 empaquetado).

══════════════════════════════════════════════════════════════════════════════

SUBMENSAJES (S ↔ C)

┌─ 0x01 HELLO / 0x02 WELCOME ────────────────────────────────────────────────┐

Cliente → Servidor (HELLO 0x01)
┌─────────────────────────────────┐
│ u8  0x01                        │
│ u8  client_protocol_version     │
│ u32 preferred_updates_hz        │ (sugerido; el server decide)
└─────────────────────────────────┘

Servidor → Cliente (WELCOME 0x02)
┌─────────────────────────────────┐
│ u8   0x02                       │
│ u32  assigned_client_id         │
│ u8   server_protocol_version    │
│ u8   tick_rate_hz               │
│ u8   flags                      │ (bit0: uses_quantization, bit1: uses_rle, ...)
└─────────────────────────────────┘

┌─ 0x03 SET_INTEREST ─────────────────────────────────────────────────────────┐

Cliente → Servidor: actualiza su centro de interés para culling.
┌─────────────────────────────────┐
│ u8   0x03                       │
│ i32  center_cx, center_cy, cz   │ // coords de chunk
│ u16  chunk_radius               │ // radio en chunks
└─────────────────────────────────┘

┌─ 0x04/0x05 JOIN/LEAVE ──────────────────────────────────────────────────────┐

Servidor → Cliente (informativo/broadcast en tu AOI):

0x04 JOIN:  u8 0x04, u32 entity_id, u8 kind(0=player,1=npc,...)
0x05 LEAVE: u8 0x05, u32 entity_id

══════════════════════════════════════════════════════════════════════════════

ACTUALIZACIONES DE ENTIDADES (JUGADORES/PNJ)

┌─ Component mask (bitfield) ─────────────────────────────────────────────────┐

Define qué campos vienen en este submensaje:

bit0: Position     bit1: Orientation     bit2: Velocity      (opcional)
bit3: StateBits    bit4: AnimState      (si lo separas)      ... (reservado)

┌─ Cuantización recomendada ──────────────────────────────────────────────────┐

• Posición:
  ▸ Opción A (global simple): s32 en milímetros (pos_mm = round(pos_m * 1000)).
  ▸ Opción B (más compacta en mundos grandes): posición relativa al chunk →
    s16 por eje en centímetros (±327.67 m de rango local por eje).
• Orientación:
  ▸ Suelo / 3D estándar: yaw u16 (0..65535 ≈ 0..360°), pitch i16 (−90..+90 mapeado), roll opcional i16.
  ▸ Si solo 2D: solo yaw.
• Velocity (si sirve para predicción): i16 por eje en cm/s.
• StateBits: u16 (ej., on_ground=1, crouch=2, jumping=4, stunned=8, etc.).
• AnimState: u8 (idle/run/jump/attack…), o amplía a u16.

┌─ 0x06 ENTITIES_UPDATE (S → C) ──────────────────────────────────────────────┐

Paquete batched por tick con N entidades (solo las que cambiaron).

┌─────────────────────────────────┐
│ u8   0x06                       │
│ u16  count                      │
│ repeat count times:             │
│   u32 entity_id                 │ (delta-coded opcional)
│   u8  comp_mask                 │
│                                 │
│   if comp_mask&1:   // Position │
│      (modo A) s32 x,y,z         │
│      (modo B) s16 lx,ly,lz +    │
│                i32 cx,cy,cz     │ (si cambió de chunk; si no, omitir y marcar "same_chunk")
│   if comp_mask&2:   // Orient   │
│      u16 yaw; i16 pitch;        │ [i16 roll?]
│   if comp_mask&4:   // Velocity │
│      i16 vx,vy,vz               │
│   if comp_mask&8:   // StateBits│
│      u16 state                  │
│   if comp_mask&16:  // AnimState│
│      u8 anim                    │
└─────────────────────────────────┘

Nota: Añade un bit "same_chunk" en comp_mask alto (ej. bit7) para indicar que no envías cx,cy,cz.
Si cambió de chunk, incluye los 3 i32.

┌─ 0x07 CLIENT_INPUT/POSE (C → S) ────────────────────────────────────────────┐

Si vas a empezar simple: el cliente manda su pose; en futuro, mejor mandar input (teclas) y que el server integre.

┌─────────────────────────────────┐
│ u8  0x07                        │
│ u8  mask                        │ (bit0: pos, bit1: yaw_pitch, bit2: velocity_hint)
│ if mask&1: (Pos)                │ s16 lx,ly,lz + i32 cx,cy,cz (o s32 xyz global)
│ if mask&2: (Ori)                │ u16 yaw; i16 pitch
│ if mask&4: (Vel)                │ i16 vx,vy,vz
└─────────────────────────────────┘

══════════════════════════════════════════════════════════════════════════════

MUNDO VOXEL

┌─ Chunks y versiones ────────────────────────────────────────────────────────┐

• Cada chunk (cx,cy,cz) mantiene un u32 version.
• El servidor envía:
  ▸ Snapshot cuando el cliente entra por primera vez (o si hay desync/hash distinto).
  ▸ Deltas cuando hay ediciones puntuales.
• El cliente ackea última versión conocida en 0x0B (opcional para depurar).

┌─ Representación de voxel ───────────────────────────────────────────────────┐

• PaletteId (u16): mapea a color o textura (el cliente tiene una tabla).
• VoxelFlags (u8): bit0=destroyed, bit1=modified, bit2=rotated, …
• Rotación: si aplicable, u8 rot (0..23 para las 24 orientaciones ortogonales; o u16 yaw si necesitas continuo).

┌─ 0x08 CHUNK_SNAPSHOT (S → C) ───────────────────────────────────────────────┐

┌─────────────────────────────────┐
│ u8   0x08                       │
│ i32  cx,cy,cz                   │
│ u32  version                    │
│ u16  palette_len                │
│ repeat palette_len:             │
│   u16 palette_id                │ // (o mapea a índices locales 0..palette_len-1)
│                                 │
│ u8   encoding                   │ // 0=RAW, 1=RLE, 2=RLE+bitmask
│ payload...                      │
└─────────────────────────────────┘

RAW compacto (paleta local):
• Primero un bitset de ocupación de 4096 voxels (4096 bits = 512 bytes).
• Luego, para cada voxel ocupado, u16 local_palette_index + [u8 flags] + [u8 rot opcional].

RLE simple:
• Secuencias (run_len u16, kind u16, flags u8 [rot]) sobre un escaneo z-y-x.
• Sencillo de implementar, muy efectivo en mundos homogéneos.

Nota: Empieza con RAW+bitset (muy fácil y rápido). Si duele el ancho de banda, añade el RLE.

┌─ 0x09 CHUNK_DELTA (S → C) ──────────────────────────────────────────────────┐

Para ediciones dispersas:

┌─────────────────────────────────┐
│ u8   0x09                       │
│ i32  cx,cy,cz                   │
│ u32  base_version               │ // versión que asume el delta
│ u16  edit_count                 │
│ repeat edit_count:              │
│   u16 v_local_index             │ // 0..4095 (vx|vy<<4|vz<<8)
│   u8  flags                     │
│   if !(flags & 1 /*destroyed*/):|
│       u16 local_palette_index   │
│       if (flags & 4 /*rotated*/)│: u8 rot
└─────────────────────────────────┘

Nota: Si base_version no coincide con el cliente, reenvía snapshot; TCP garantiza orden,
pero este guardarraíl evita aplicar un delta sobre base desconocida.

┌─ 0x0A CLIENT_CHUNK_REQUEST (C → S) ─────────────────────────────────────────┐

Para pedir (re)envío de chunks:

┌─────────────────────────────────┐
│ u8   0x0A                       │
│ u16  count                      │
│ repeat count:                   │
│   i32 cx,cy,cz                  │
└─────────────────────────────────┘

┌─ 0x0B CHUNK_ACK (C → S) [opcional] ─────────────────────────────────────────┐

┌─────────────────────────────────┐
│ u8   0x0B                       │
│ u16  count                      │
│ repeat count:                   │
│   i32 cx,cy,cz                  │
│   u32 version                   │
└─────────────────────────────────┘

══════════════════════════════════════════════════════════════════════════════

ESTADOS Y ANIMACIONES

• Player StateBits (u16) propuesto:
  ▸ bit0 on_ground, bit1 crouch, bit2 jumping, bit3 sprint, bit4 stunned, bit5 noclip, bit6 busy, bit7 reserved…
• Voxel Flags (u8):
  ▸ bit0 destroyed, bit1 modified (custom data), bit2 rotated, bit3 wet, bit4 hot, …

Nota: Compacta estados booleanos en bitfields. Campos numéricos opcionales (salud, temperatura)
puedes enviarlos solo cuando cambien (máscara de componentes).

══════════════════════════════════════════════════════════════════════════════

TAMAÑOS ORIENTATIVOS (3D, cuantizado)

• Entity update típica (pos+ori):
  u8 type + u16 count + (u32 id + u8 mask + s16*3 + u16 + i16) = ~1 + 2 + (4 + 1 + 6 + 2 + 2) = ~18 bytes por entidad
  (vs 1+4+12+8 ≈ 25 con floats).
• Delta voxel (una edición): 2 + 1 + (2 + [1]) ≈ 5–6 bytes por voxel editado (sin destroyed ≈ +2).

══════════════════════════════════════════════════════════════════════════════

FLUJOS TÍPICOS

1. Conexión: HELLO → WELCOME (id, tick_rate).
2. Interés: SET_INTEREST (centro + radio).
3. Server:
   ▸ Envía JOIN de entidades en AOI y CHUNK_SNAPSHOT de chunks visibles.
   ▸ En cada tick, manda ENTITIES_UPDATE con máscara por entidad cambiada y CHUNK_DELTA si hubo ediciones.
4. Cliente:
   ▸ Manda CLIENT_INPUT/POSE a 20–60 Hz.
   ▸ Pide chunks faltantes con CLIENT_CHUNK_REQUEST si detecta huecos.
   ▸ (Opcional) ACKea versiones de chunk.

══════════════════════════════════════════════════════════════════════════════

DECISIONES DE PERFORMANCE (POR QUÉ ASÍ)

• Máscaras + cuantización: envías solo cambios y en enteros pequeños → menos GC/allocs, menor latencia.
• Batching por tick: N mensajes → 1 frame WS. Reduce syscalls, headers y lock contention.
• Índice u16 del voxel: 2 bytes por posición local, cache-friendly, fácil de convertir a (vx,vy,vz) con mascaras y shifts.
• Versionado de chunk: evita aplicar deltas sobre base equivocada sin necesidad de retransmisión compleja.
• Interés por chunk: culling natural para voxels; no calculas AOI por-voxel.

══════════════════════════════════════════════════════════════════════════════

IMPLEMENTACIÓN MÍNIMA EN RUST (GUÍA)

• Define enums SubMsgKind y helpers de lectura/escritura (LE).
• Usa buffers pre-reservados por frame (Vec::with_capacity).
• Para ENTITIES_UPDATE:
  ▸ Ordena por entity_id, opcionalmente delta-code el id (varint casero si quieres: LEB128 en pocas líneas).
  ▸ Reutiliza un Vec<u8> por tick.
• Para CHUNK_SNAPSHOT/DELTA:
  ▸ Mantén HashMap<(cx,cy,cz), Chunk> con version y Vec<Voxel>.
  ▸ Genera snapshot con bitset + data; añade RLE cuando lo necesites.
• Backpressure:
  ▸ Cola mpsc acotada por cliente (ej., 256). Política: drop oldest para mensajes ephemerales; críticos siempre pasan.
  ▸ Marca submensajes con un byte de clase para poder colapsar fácilmente en la cola
    (ej., reemplazar ENTITIES_UPDATE anterior por el nuevo del mismo tick).

══════════════════════════════════════════════════════════════════════════════

RUTA DE EVOLUCIÓN (SIN AÑADIR MUCHAS DEPS)

1. v0: sin varints; usa s16/s32/u16/u32 fijos, máscara de componentes y batching.
2. v1: añade varint para entity_id delta-coded y edit_count.
3. v2: RLE para snapshots/deltas de voxels.
4. v3: compresión de paleta (mapa global → local por chunk).
5. v4: canal "fiable" y "ephemeral" encolados por separado dentro del mismo frame (solo lógica).

══════════════════════════════════════════════════════════════════════════════

CHECK-LIST DE DECISIONES RECOMENDADAS

☐ Chunk size = 16×16×16 (OK).
☐ Pos cuantizada relativa a chunk: s16 cm + i32 chunk coords.
☐ Orientación: yaw u16, pitch i16, roll opcional.
☐ State bits: u16 jugadores; u8 voxels.
☐ ENTITIES_UPDATE 0x06 con mask y batching por tick.
☐ CHUNK_SNAPSHOT 0x08 (bitset + datos) y CHUNK_DELTA 0x09 (lista de ediciones).
☐ SET_INTEREST 0x03 por chunks (centro+radio).
☐ Colas por cliente acotadas con drop oldest para updates de entidad.

BINARY PROTOCOL FOR PLAYER AND VOXEL SYNCHRONIZATION OVER WEBSOCKETS

══════════════════════════════════════════════════════════════════════════════

DESIGN PRINCIPLES

• Frame batching: one WebSocket frame can contain multiple submessages. Fewer syscalls and overhead.
• Authoritative server + tick: the server processes at fixed tick_rate (e.g., 30 Hz) and packages the changes from that tick.
• Spatial interest: the client publishes its center of interest and the server only sends nearby entities/voxels.
• Component masks: each update declares which fields changed; identical data is not repeated.
• Quantization: use compact integers instead of f32 where reasonable (bandwidth and cache savings).
• Reliability classes (logical):
  ▸ Critical (join/leave, chunk/voxel changes, snapshots): always sent (TCP (Transmission Control Protocol) already guarantees).
  ▸ Ephemeral (high-frequency position/orientation): collapsed; if a client queue fills up, old data is discarded.
• LE (little-endian) everywhere.
• No WebSocket compression initially; if any payload grows (e.g., chunk snapshots), add simple custom RLE (Run-Length Encoding).

══════════════════════════════════════════════════════════════════════════════

GENERAL ENCAPSULATION

Each WebSocket frame from server to client is:

┌─ FrameHeader ─────────────────────────┐
│ u8  type = 0x10 (ServerFrame)         │
│ u32 tick        (monotonic, wrap ok)  │
│ u8  submsg_count                      │
└───────────────────────────────────────┘
[SubMsg]*        (submsg_count entries)

Client → Server:

┌─ ClientFrame ─────────────────────────┐
│ u8  type = 0x11                       │
│ u32 client_tick_or_seq                │
│ u8  submsg_count                      │
└───────────────────────────────────────┘
[SubMsg]*

Note: You can send multiple SubMsg in a single WebSocket frame. If you prefer ultra-simple,
you can also send submessages as independent WebSocket frames: the content doesn't change.

══════════════════════════════════════════════════════════════════════════════

IDENTIFIERS AND RANGES

• EntityId: u32 (players/NPC (Non-Player Character)/objects).
• Chunk coord: voxel world partitioned into 16×16×16 chunks:
  ▸ i32 cx, cy, cz for absolute chunks.
  ▸ Local voxel index: u16 v = vx | (vy<<4) | (vz<<8) with vx,vy,vz ∈ [0,15].
• TextureId/PaletteId: u16 (if you run short, move to packed u24).

══════════════════════════════════════════════════════════════════════════════

SUBMESSAGES (S ↔ C)

┌─ 0x01 HELLO / 0x02 WELCOME ────────────────────────────────────────────────┐

Client → Server (HELLO 0x01)
┌─────────────────────────────────┐
│ u8  0x01                        │
│ u8  client_protocol_version     │
│ u32 preferred_updates_hz        │ (suggested; server decides)
└─────────────────────────────────┘

Server → Client (WELCOME 0x02)
┌─────────────────────────────────┐
│ u8   0x02                       │
│ u32  assigned_client_id         │
│ u8   server_protocol_version    │
│ u8   tick_rate_hz               │
│ u8   flags                      │ (bit0: uses_quantization, bit1: uses_rle, ...)
└─────────────────────────────────┘

┌─ 0x03 SET_INTEREST ─────────────────────────────────────────────────────────┐

Client → Server: updates its center of interest for culling.
┌─────────────────────────────────┐
│ u8   0x03                       │
│ i32  center_cx, center_cy, cz   │ // chunk coordinates
│ u16  chunk_radius               │ // radius in chunks
└─────────────────────────────────┘

┌─ 0x04/0x05 JOIN/LEAVE ──────────────────────────────────────────────────────┐

Server → Client (informative/broadcast in your AOI (Area of Interest)):

0x04 JOIN:  u8 0x04, u32 entity_id, u8 kind(0=player,1=npc,...)
0x05 LEAVE: u8 0x05, u32 entity_id

══════════════════════════════════════════════════════════════════════════════

ENTITY UPDATES (PLAYERS/NPCs)

┌─ Component mask (bitfield) ─────────────────────────────────────────────────┐

Defines which fields come in this submessage:

bit0: Position     bit1: Orientation     bit2: Velocity      (optional)
bit3: StateBits    bit4: AnimState      (if separated)      ... (reserved)

┌─ Recommended quantization ──────────────────────────────────────────────────┐

• Position:
  ▸ Option A (simple global): s32 in millimeters (pos_mm = round(pos_m * 1000)).
  ▸ Option B (more compact in large worlds): position relative to chunk →
    s16 per axis in centimeters (±327.67 m local range per axis).
• Orientation:
  ▸ Ground / standard 3D: yaw u16 (0..65535 ≈ 0..360°), pitch i16 (−90..+90 mapped), optional roll i16.
  ▸ If only 2D: only yaw.
• Velocity (if useful for prediction): i16 per axis in cm/s.
• StateBits: u16 (e.g., on_ground=1, crouch=2, jumping=4, stunned=8, etc.).
• AnimState: u8 (idle/run/jump/attack…), or expand to u16.

┌─ 0x06 ENTITIES_UPDATE (S → C) ──────────────────────────────────────────────┐

Batched packet per tick with N entities (only those that changed).

┌─────────────────────────────────┐
│ u8   0x06                       │
│ u16  count                      │
│ repeat count times:             │
│   u32 entity_id                 │ (optional delta-coded)
│   u8  comp_mask                 │
│                                 │
│   if comp_mask&1:   // Position │
│      (mode A) s32 x,y,z         │
│      (mode B) s16 lx,ly,lz +    │
│                i32 cx,cy,cz     │ (if chunk changed; if not, omit and mark "same_chunk")
│   if comp_mask&2:   // Orient   │
│      u16 yaw; i16 pitch;        │ [i16 roll?]
│   if comp_mask&4:   // Velocity │
│      i16 vx,vy,vz               │
│   if comp_mask&8:   // StateBits│
│      u16 state                  │
│   if comp_mask&16:  // AnimState│
│      u8 anim                    │
└─────────────────────────────────┘

Note: Add a "same_chunk" bit in high comp_mask (e.g. bit7) to indicate you're not sending cx,cy,cz.
If chunk changed, include the 3 i32.

┌─ 0x07 CLIENT_INPUT/POSE (C → S) ────────────────────────────────────────────┐

If starting simple: client sends its pose; in future, better to send input (keys) and let server integrate.

┌─────────────────────────────────┐
│ u8  0x07                        │
│ u8  mask                        │ (bit0: pos, bit1: yaw_pitch, bit2: velocity_hint)
│ if mask&1: (Pos)                │ s16 lx,ly,lz + i32 cx,cy,cz (or s32 xyz global)
│ if mask&2: (Ori)                │ u16 yaw; i16 pitch
│ if mask&4: (Vel)                │ i16 vx,vy,vz
└─────────────────────────────────┘

══════════════════════════════════════════════════════════════════════════════

VOXEL WORLD

┌─ Chunks and versions ───────────────────────────────────────────────────────┐

• Each chunk (cx,cy,cz) maintains a u32 version.
• The server sends:
  ▸ Snapshot when client enters for the first time (or if there's desync/different hash).
  ▸ Deltas when there are point edits.
• The client acks last known version in 0x0B (optional for debugging).

┌─ Voxel representation ──────────────────────────────────────────────────────┐

• PaletteId (u16): maps to color or texture (client has a table).
• VoxelFlags (u8): bit0=destroyed, bit1=modified, bit2=rotated, …
• Rotation: if applicable, u8 rot (0..23 for the 24 orthogonal orientations; or u16 yaw if you need continuous).

┌─ 0x08 CHUNK_SNAPSHOT (S → C) ───────────────────────────────────────────────┐

┌─────────────────────────────────┐
│ u8   0x08                       │
│ i32  cx,cy,cz                   │
│ u32  version                    │
│ u16  palette_len                │
│ repeat palette_len:             │
│   u16 palette_id                │ // (or map to local indices 0..palette_len-1)
│                                 │
│ u8   encoding                   │ // 0=RAW, 1=RLE, 2=RLE+bitmask
│ payload...                      │
└─────────────────────────────────┘

Compact RAW (local palette):
• First an occupancy bitset of 4096 voxels (4096 bits = 512 bytes).
• Then, for each occupied voxel, u16 local_palette_index + [u8 flags] + [optional u8 rot].

Simple RLE:
• Sequences (run_len u16, kind u16, flags u8 [rot]) over a z-y-x scan.
• Simple to implement, very effective in homogeneous worlds.

Note: Start with RAW+bitset (very easy and fast). If bandwidth hurts, add RLE.

┌─ 0x09 CHUNK_DELTA (S → C) ──────────────────────────────────────────────────┐

For sparse edits:

┌─────────────────────────────────┐
│ u8   0x09                       │
│ i32  cx,cy,cz                   │
│ u32  base_version               │ // version the delta assumes
│ u16  edit_count                 │
│ repeat edit_count:              │
│   u16 v_local_index             │ // 0..4095 (vx|vy<<4|vz<<8)
│   u8  flags                     │
│   if !(flags & 1 /*destroyed*/):|
│       u16 local_palette_index   │
│       if (flags & 4 /*rotated*/)│: u8 rot
└─────────────────────────────────┘

Note: If base_version doesn't match client, resend snapshot; TCP guarantees order,
but this guard prevents applying a delta over unknown base.

┌─ 0x0A CLIENT_CHUNK_REQUEST (C → S) ─────────────────────────────────────────┐

To request (re)sending of chunks:

┌─────────────────────────────────┐
│ u8   0x0A                       │
│ u16  count                      │
│ repeat count:                   │
│   i32 cx,cy,cz                  │
└─────────────────────────────────┘

┌─ 0x0B CHUNK_ACK (C → S) [optional] ─────────────────────────────────────────┐

┌─────────────────────────────────┐
│ u8   0x0B                       │
│ u16  count                      │
│ repeat count:                   │
│   i32 cx,cy,cz                  │
│   u32 version                   │
└─────────────────────────────────┘

══════════════════════════════════════════════════════════════════════════════

STATES AND ANIMATIONS

• Player StateBits (u16) proposed:
  ▸ bit0 on_ground, bit1 crouch, bit2 jumping, bit3 sprint, bit4 stunned, bit5 noclip, bit6 busy, bit7 reserved…
• Voxel Flags (u8):
  ▸ bit0 destroyed, bit1 modified (custom data), bit2 rotated, bit3 wet, bit4 hot, …

Note: Pack boolean states into bitfields. Optional numeric fields (health, temperature)
can be sent only when they change (component masks).

══════════════════════════════════════════════════════════════════════════════

APPROXIMATE SIZES (3D, quantized)

• Typical entity update (pos+ori):
  u8 type + u16 count + (u32 id + u8 mask + s16*3 + u16 + i16) = ~1 + 2 + (4 + 1 + 6 + 2 + 2) = ~18 bytes per entity
  (vs 1+4+12+8 ≈ 25 with floats).
• Voxel delta (one edit): 2 + 1 + (2 + [1]) ≈ 5–6 bytes per edited voxel (without destroyed ≈ +2).

══════════════════════════════════════════════════════════════════════════════

TYPICAL FLOWS

1. Connection: HELLO → WELCOME (id, tick_rate).
2. Interest: SET_INTEREST (center + radius).
3. Server:
   ▸ Sends JOIN of entities in AOI and CHUNK_SNAPSHOT of visible chunks.
   ▸ Each tick, sends ENTITIES_UPDATE with mask per changed entity and CHUNK_DELTA if there were edits.
4. Client:
   ▸ Sends CLIENT_INPUT/POSE at 20–60 Hz.
   ▸ Requests missing chunks with CLIENT_CHUNK_REQUEST if gaps detected.
   ▸ (Optional) ACKs chunk versions.

══════════════════════════════════════════════════════════════════════════════

PERFORMANCE DECISIONS (WHY THIS WAY)

• Masks + quantization: send only changes and in small integers → less GC (Garbage Collection)/allocs, lower latency.
• Batching per tick: N messages → 1 WebSocket frame. Reduces syscalls, headers and lock contention.
• u16 voxel index: 2 bytes per local position, cache-friendly, easy to convert to (vx,vy,vz) with masks and shifts.
• Chunk versioning: prevents applying deltas over wrong base without complex retransmission.
• Interest per chunk: natural culling for voxels; don't calculate AOI per-voxel.

══════════════════════════════════════════════════════════════════════════════

MINIMAL RUST IMPLEMENTATION (GUIDE)

• Define SubMsgKind enums and read/write helpers (LE).
• Use pre-reserved buffers per frame (Vec::with_capacity).
• For ENTITIES_UPDATE:
  ▸ Sort by entity_id, optionally delta-code the id (custom varint if desired: LEB128 in few lines).
  ▸ Reuse a Vec<u8> per tick.
• For CHUNK_SNAPSHOT/DELTA:
  ▸ Maintain HashMap<(cx,cy,cz), Chunk> with version and Vec<Voxel>.
  ▸ Generate snapshot with bitset + data; add RLE when needed.
• Backpressure:
  ▸ Bounded mpsc queue per client (e.g., 256). Policy: drop oldest for ephemeral messages; critical always pass.
  ▸ Mark submessages with a class byte to easily collapse in queue
    (e.g., replace previous ENTITIES_UPDATE with new one from same tick).

══════════════════════════════════════════════════════════════════════════════

EVOLUTION PATH (WITHOUT ADDING MANY DEPS)

1. v0: no varints; use fixed s16/s32/u16/u32, component masks and batching.
2. v1: add varint for delta-coded entity_id and edit_count.
3. v2: RLE for voxel snapshots/deltas.
4. v3: palette compression (global → local map per chunk).
5. v4: "reliable" and "ephemeral" channels queued separately within same frame (logic only).

══════════════════════════════════════════════════════════════════════════════

RECOMMENDED DECISIONS CHECKLIST

☐ Chunk size = 16×16×16 (OK).
☐ Quantized pos relative to chunk: s16 cm + i32 chunk coords.
☐ Orientation: yaw u16, pitch i16, optional roll.
☐ State bits: u16 players; u8 voxels.
☐ ENTITIES_UPDATE 0x06 with mask and batching per tick.
☐ CHUNK_SNAPSHOT 0x08 (bitset + data) and CHUNK_DELTA 0x09 (edit list).
☐ SET_INTEREST 0x03 per chunks (center+radius).
☐ Bounded queues per client with drop oldest for entity updates.
